# Result type API improvements

* **Type**: Standard Library API proposal
* **Author**: Artem Zinnatullin
* **Status**: Not implemented
* **Related KEEP**: [KEEP-127](https://github.com/Kotlin/KEEP/pull/127)
* **Discussion**: [KEEP-159](https://github.com/Kotlin/KEEP/issues/159)

## Summary

Provide better public API for `Result` type (also known as `SuccessOrFailure`):

- Represent `Result` cases as public sealed class subtypes
- Allow a failure case to store anything instead of just Throwable
- Change names of `Result` cases to more concise ones

## Motivation

Given that the `Result` type is placed directly in `kotlin`
package, and now that it's [renamed](#159) to `Result` from `SuccessOrFailure`,
it's becoming clear that `Result` type might have a wide adoption
outside of code generated by compiler for coroutines in
future.

Right now, `Result` type feels like a Frankenstein, built from different pieces that don't seem to work well in
combination and might fall apart if used heavily (no offence intended, design is hard).

That's why it's important to address several aspects of its API for the future of the Kotlin language.

### Motivation: Represent `Result` cases as public sealed class subtypes

At the moment, `Result` [is represented](https://github.com/JetBrains/kotlin/blob/974837654e0f92ac0968dd68c6e76da1be1158bf/libraries/stdlib/coroutines/src/kotlin/Result.kt) as an `inline` class where its successful case is actually `Result` itself
while failure is represented as an `internal` class `Failure`.

Given these technical aspects, `Result` has to expose two `Boolean` properties: `isSuccess` and `isFailure` to let the user to distinguish between cases.

Unfortunately, there are multiple problems with `isSuccess` and `isFailure` properties:

- Feature that everyone loves Kotlin for, SmartCast does not work with boolean properties like that (unless a compiler Contract is implemented).
    - That forces `Result` to expose a weird set of functions (that are somewhat similar to those of [Java™️ `Optional`](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html)):
        - `getOrDefault()`
        - `getOrElse()`
        - `exceptionOrNull()` (this one probably should have been named `throwableOrNull()`
        - `onSuccess()`
        - `onFailure()`
        - Most if not all of these functions could be eliminated if proper `is` support with SmartCast would be implemented
- Compiler does not view `success` or `failure` cases as "Either" in `when` statements,
    - This allows user to make a mistake by only handling one of the cases which dismisses major safety point of `Result` type when used by humans

### Motivation: Allow a failure case to store anything instead of just Throwable

At the moment, `Result` type only allows a `Throwable` to be a value of `Failure` case.

Unfortunately, there are multiple problems with that approach:

- Information about `Throwable` subtype is lost as soon as you create `Result.failure()`
- While `Throwable` is a good representation of a runtime failure such as Java exceptions, it comes with negative aspects:
    - It takes time to capture call stacktrace to create a `Throwable`
    - It enforces type hierarchy which a user might not be interested in, ie `Exception` vs `Error` vs `RuntimeException` vs `Throwable` in Java
    - `Throwable`s are not "values", it's

### Motivation: Change names of `Result` cases to more concise ones

`Success` and `Failure` are good names, however they're quite long.

As [KEEP 127](https://github.com/Kotlin/KEEP/pull/127) already points out, some other languages like Rust, [have similar
`Result` type](https://doc.rust-lang.org/std/result/enum.Result.html).

But Rust also adopted shorter names for their `Result` cases: `Ok` and `Err`, likely for sake of being more
concise (one can definitely feel it when writing programs in Rust).

Thus this KEEP suggests a rename, however goes a bit further than Rust and addresses the
issue of horizontally unaligned `when` statements by using names with same amount of characters (2):

- `Success` → `Ok`
- `Failure` → `Er`
